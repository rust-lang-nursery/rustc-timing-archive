commit 435246bb49226d08f22dfd317954fe015a4b3e91
Merge: 87b76a5 276f052
Author: bors <bors@rust-lang.org>
Date:   Sun Nov 13 19:46:34 2016 -0800

    Auto merge of #37640 - michaelwoerister:llvm-type-names, r=brson
    
    trans: Make type names in LLVM IR independent of crate-nums and source locations.
    
    UPDATE:
    This PR makes the type names we assign in LLVM IR independent of the type definition's location in the source code and the order in which extern crates are loaded. The new type names look like the old ones, except for closures and the `<crate-num>.` prefix being gone. Resolution of name clashes (e.g. of the same type in different crate versions) is left to LLVM (which will just append `.<counter>` to the name).
    
    ORIGINAL TEXT:
    This PR makes the type names we assign in LLVM IR independent of the type definition's location in the source code. Before, the type of closures contained the closures definition location. The new naming scheme follows the same pattern that we already use for symbol names: We have a human readable prefix followed by a hash that makes sure we don't have any collisions. Here is an example of what the new names look like:
    
    ```rust
    // prog.rs - example program
    
    mod mod1
    {
        pub struct Struct<T>(pub T);
    }
    
    fn main() {
        use mod1::Struct;
    
        let _s = Struct(0u32);
        let _t = Struct('h');
        let _x = Struct(Struct(0i32));
    }
    ```
    Old:
    ```llvm
    %"mod1::Struct<u32>" = type { i32 }
    %"mod1::Struct<char>" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>" = type { %"mod1::Struct<i32>" }
    %"mod1::Struct<i32>" = type { i32 }
    ```
    New:
    ```llvm
    %"prog::mod1::Struct<u32>::ejDrT" = type { i32 }
    %"prog::mod1::Struct<char>::2eEAU" = type { i32 }
    %"prog::mod1::Struct<prog::mod1::Struct<i32>>::ehCqR" = type { %"prog::mod1::Struct<i32>::$fAo2" }
    %"prog::mod1::Struct<i32>::$fAo2" = type { i32 }
    ```
    
    As you can see, the new names are slightly more verbose, but also more consistent. There is no difference now between a local type and one from another crate (before, non-local types where prefixed with `<crate-num>.` as in `2.std::mod1::Type1`).
    
    There is a bit of design space here. For example, we could leave off the crate name for local definitions (making names shorter but less consistent):
    ```llvm
    %"mod1::Struct<u32>::ejDrT" = type { i32 }
    %"mod1::Struct<char>::2eEAU" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>::ehCqR" = type { %"mod1::Struct<i32>::$fAo2" }
    %"mod1::Struct<i32>::$fAo2" = type { i32 }
    ```
    
    We could also put the hash in front, which might be more readable:
    ```llvm
    %"ejDrT.mod1::Struct<u32>" = type { i32 }
    %"2eEAU.mod1::Struct<char>" = type { i32 }
    %"ehCqR.mod1::Struct<mod1::Struct<i32>>" = type { %"$fAo2.mod1::Struct<i32>" }
    %"$fAo2.mod1::Struct<i32>" = type { i32 }
    ```
    
    We could probably also get rid of the hash if we used full DefPaths and crate-nums (though I'm not yet a 100% sure if crate-nums could mess with incremental compilation).
    
    ```llvm
    %"mod1::Struct<u32>" = type { i32 }
    %"mod1::Struct<char>" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>" = type { %"mod1::Struct<i32>" }
    %"mod1::Struct<i32>" = type { i32 }
    %"2.std::mod1::Type1" = type { ... }
    ```
    I would prefer the solution with the hashes because it is nice and consistent conceptually, but visually it's admittedly a bit uglier. Maybe @rust-lang/compiler would like to bikeshed a little about this.
    
    On a related note: Has anyone ever tried if the LTO-linker will merge equal types with different names?
    (^ @brson, @alexcrichton ^)
    If not, that would be a reason to make type names more consistent.
rustc: ./helloworld
cargo rustc  -- -Ztime-passes -Zinput-stats
   Compiling helloworld v0.1.0 (file:///root/benchmarks/helloworld)
time: 0.000; rss: 41MB	parsing
Lines of code:             3
Pre-expansion node count:  8
time: 0.000; rss: 41MB	recursion limit
time: 0.000; rss: 41MB	crate injection
time: 0.000; rss: 41MB	plugin loading
time: 0.000; rss: 41MB	plugin registration
time: 0.012; rss: 62MB	expansion
time: 0.000; rss: 62MB	maybe building test harness
time: 0.000; rss: 62MB	maybe creating a macro crate
Post-expansion node count: 68
time: 0.000; rss: 62MB	checking for inline asm in case the target doesn't support it
time: 0.000; rss: 62MB	complete gated feature checking
time: 0.000; rss: 62MB	early lint checks
time: 0.000; rss: 62MB	AST validation
time: 0.002; rss: 62MB	name resolution
time: 0.000; rss: 62MB	lowering ast -> hir
time: 0.000; rss: 66MB	indexing hir
time: 0.000; rss: 66MB	attribute checking
time: 0.000; rss: 66MB	language item collection
time: 0.000; rss: 66MB	lifetime resolution
time: 0.000; rss: 66MB	looking for entry point
time: 0.000; rss: 66MB	looking for plugin registrar
time: 0.000; rss: 66MB	region resolution
time: 0.000; rss: 66MB	loop checking
time: 0.000; rss: 66MB	static item recursion checking
time: 0.000; rss: 66MB	compute_incremental_hashes_map
time: 0.000; rss: 66MB	load_dep_graph
time: 0.000; rss: 66MB	type collecting
time: 0.000; rss: 66MB	variance inference
time: 0.004; rss: 66MB	coherence checking
time: 0.000; rss: 66MB	wf checking
time: 0.000; rss: 66MB	item-types checking
time: 0.000; rss: 66MB	item-bodies checking
time: 0.000; rss: 66MB	drop-impl checking
time: 0.000; rss: 66MB	const checking
time: 0.000; rss: 66MB	privacy checking
time: 0.000; rss: 66MB	stability index
time: 0.000; rss: 66MB	intrinsic checking
time: 0.000; rss: 66MB	effect checking
time: 0.000; rss: 66MB	match checking
time: 0.000; rss: 66MB	liveness checking
time: 0.000; rss: 66MB	rvalue checking
time: 0.000; rss: 66MB	MIR dump
  time: 0.000; rss: 66MB	SimplifyCfg
  time: 0.000; rss: 66MB	QualifyAndPromoteConstants
  time: 0.000; rss: 66MB	TypeckMir
  time: 0.000; rss: 66MB	SimplifyBranches
  time: 0.000; rss: 66MB	SimplifyCfg
time: 0.000; rss: 66MB	MIR cleanup and validation
time: 0.000; rss: 66MB	borrow checking
time: 0.000; rss: 66MB	reachability checking
time: 0.000; rss: 66MB	death checking
time: 0.000; rss: 66MB	stability checking
time: 0.000; rss: 66MB	unused lib feature checking
time: 0.000; rss: 66MB	lint checking
time: 0.001; rss: 66MB	resolving dependency formats
  time: 0.000; rss: 66MB	NoLandingPads
  time: 0.000; rss: 66MB	SimplifyCfg
  time: 0.000; rss: 66MB	EraseRegions
  time: 0.000; rss: 66MB	AddCallGuards
  time: 0.000; rss: 66MB	ElaborateDrops
  time: 0.000; rss: 66MB	NoLandingPads
  time: 0.000; rss: 66MB	SimplifyCfg
  time: 0.000; rss: 66MB	InstCombine
  time: 0.000; rss: 66MB	Deaggregator
  time: 0.000; rss: 66MB	CopyPropagation
  time: 0.000; rss: 66MB	SimplifyLocals
  time: 0.000; rss: 66MB	AddCallGuards
  time: 0.000; rss: 66MB	PreTrans
time: 0.000; rss: 66MB	MIR optimisations
  time: 0.000; rss: 71MB	write metadata
  time: 0.000; rss: 71MB	translation item collection
  time: 0.000; rss: 71MB	codegen unit partitioning
  time: 0.000; rss: 74MB	internalize symbols
time: 0.003; rss: 74MB	translation
time: 0.000; rss: 74MB	assert dep graph
time: 0.000; rss: 74MB	serialize dep graph
  time: 0.000; rss: 74MB	llvm function passes [0]
  time: 0.000; rss: 74MB	llvm module passes [0]
  time: 0.002; rss: 74MB	codegen passes [0]
  time: 0.000; rss: 74MB	codegen passes [0]
time: 0.003; rss: 74MB	LLVM passes
time: 0.000; rss: 74MB	serialize work products
  time: 0.073; rss: 74MB	running linker
time: 0.074; rss: 74MB	linking
done
