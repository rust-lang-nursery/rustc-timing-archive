commit 435246bb49226d08f22dfd317954fe015a4b3e91
Merge: 87b76a5 276f052
Author: bors <bors@rust-lang.org>
Date:   Sun Nov 13 19:46:34 2016 -0800

    Auto merge of #37640 - michaelwoerister:llvm-type-names, r=brson
    
    trans: Make type names in LLVM IR independent of crate-nums and source locations.
    
    UPDATE:
    This PR makes the type names we assign in LLVM IR independent of the type definition's location in the source code and the order in which extern crates are loaded. The new type names look like the old ones, except for closures and the `<crate-num>.` prefix being gone. Resolution of name clashes (e.g. of the same type in different crate versions) is left to LLVM (which will just append `.<counter>` to the name).
    
    ORIGINAL TEXT:
    This PR makes the type names we assign in LLVM IR independent of the type definition's location in the source code. Before, the type of closures contained the closures definition location. The new naming scheme follows the same pattern that we already use for symbol names: We have a human readable prefix followed by a hash that makes sure we don't have any collisions. Here is an example of what the new names look like:
    
    ```rust
    // prog.rs - example program
    
    mod mod1
    {
        pub struct Struct<T>(pub T);
    }
    
    fn main() {
        use mod1::Struct;
    
        let _s = Struct(0u32);
        let _t = Struct('h');
        let _x = Struct(Struct(0i32));
    }
    ```
    Old:
    ```llvm
    %"mod1::Struct<u32>" = type { i32 }
    %"mod1::Struct<char>" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>" = type { %"mod1::Struct<i32>" }
    %"mod1::Struct<i32>" = type { i32 }
    ```
    New:
    ```llvm
    %"prog::mod1::Struct<u32>::ejDrT" = type { i32 }
    %"prog::mod1::Struct<char>::2eEAU" = type { i32 }
    %"prog::mod1::Struct<prog::mod1::Struct<i32>>::ehCqR" = type { %"prog::mod1::Struct<i32>::$fAo2" }
    %"prog::mod1::Struct<i32>::$fAo2" = type { i32 }
    ```
    
    As you can see, the new names are slightly more verbose, but also more consistent. There is no difference now between a local type and one from another crate (before, non-local types where prefixed with `<crate-num>.` as in `2.std::mod1::Type1`).
    
    There is a bit of design space here. For example, we could leave off the crate name for local definitions (making names shorter but less consistent):
    ```llvm
    %"mod1::Struct<u32>::ejDrT" = type { i32 }
    %"mod1::Struct<char>::2eEAU" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>::ehCqR" = type { %"mod1::Struct<i32>::$fAo2" }
    %"mod1::Struct<i32>::$fAo2" = type { i32 }
    ```
    
    We could also put the hash in front, which might be more readable:
    ```llvm
    %"ejDrT.mod1::Struct<u32>" = type { i32 }
    %"2eEAU.mod1::Struct<char>" = type { i32 }
    %"ehCqR.mod1::Struct<mod1::Struct<i32>>" = type { %"$fAo2.mod1::Struct<i32>" }
    %"$fAo2.mod1::Struct<i32>" = type { i32 }
    ```
    
    We could probably also get rid of the hash if we used full DefPaths and crate-nums (though I'm not yet a 100% sure if crate-nums could mess with incremental compilation).
    
    ```llvm
    %"mod1::Struct<u32>" = type { i32 }
    %"mod1::Struct<char>" = type { i32 }
    %"mod1::Struct<mod1::Struct<i32>>" = type { %"mod1::Struct<i32>" }
    %"mod1::Struct<i32>" = type { i32 }
    %"2.std::mod1::Type1" = type { ... }
    ```
    I would prefer the solution with the hashes because it is nice and consistent conceptually, but visually it's admittedly a bit uglier. Maybe @rust-lang/compiler would like to bikeshed a little about this.
    
    On a related note: Has anyone ever tried if the LTO-linker will merge equal types with different names?
    (^ @brson, @alexcrichton ^)
    If not, that would be a reason to make type names more consistent.
rustc: ./syntex-0.42.2
cargo rustc -p syntex_syntax  -- -Ztime-passes -Zinput-stats
   Compiling syntex_syntax v0.42.0
time: 0.092; rss: 71MB	parsing
Lines of code:             33687
Pre-expansion node count:  223115
time: 0.000; rss: 71MB	recursion limit
time: 0.000; rss: 71MB	crate injection
time: 0.000; rss: 71MB	plugin loading
time: 0.000; rss: 71MB	plugin registration
time: 0.240; rss: 144MB	expansion
time: 0.000; rss: 144MB	maybe building test harness
time: 0.007; rss: 144MB	maybe creating a macro crate
Post-expansion node count: 638863
time: 0.000; rss: 144MB	checking for inline asm in case the target doesn't support it
time: 0.014; rss: 144MB	complete gated feature checking
time: 0.024; rss: 144MB	early lint checks
time: 0.008; rss: 144MB	AST validation
time: 0.081; rss: 159MB	name resolution
time: 0.050; rss: 184MB	lowering ast -> hir
time: 0.009; rss: 194MB	indexing hir
time: 0.007; rss: 194MB	attribute checking
time: 0.005; rss: 151MB	language item collection
time: 0.012; rss: 151MB	lifetime resolution
time: 0.000; rss: 151MB	looking for entry point
time: 0.000; rss: 151MB	looking for plugin registrar
time: 0.044; rss: 171MB	region resolution
time: 0.005; rss: 171MB	loop checking
time: 0.005; rss: 171MB	static item recursion checking
time: 0.333; rss: 171MB	compute_incremental_hashes_map
time: 0.000; rss: 171MB	load_dep_graph
time: 0.047; rss: 176MB	type collecting
time: 0.001; rss: 176MB	variance inference
time: 0.018; rss: 178MB	coherence checking
time: 0.090; rss: 179MB	wf checking
time: 0.177; rss: 183MB	item-types checking
time: 3.290; rss: 233MB	item-bodies checking
time: 0.000; rss: 233MB	drop-impl checking
time: 0.216; rss: 254MB	const checking
time: 0.045; rss: 254MB	privacy checking
time: 0.005; rss: 254MB	stability index
time: 0.017; rss: 254MB	intrinsic checking
time: 0.014; rss: 254MB	effect checking
time: 0.046; rss: 254MB	match checking
time: 0.048; rss: 239MB	liveness checking
time: 0.175; rss: 239MB	rvalue checking
time: 0.372; rss: 436MB	MIR dump
  time: 0.057; rss: 438MB	SimplifyCfg
  time: 0.072; rss: 438MB	QualifyAndPromoteConstants
  time: 0.101; rss: 438MB	TypeckMir
  time: 0.004; rss: 438MB	SimplifyBranches
  time: 0.031; rss: 438MB	SimplifyCfg
time: 0.265; rss: 438MB	MIR cleanup and validation
time: 0.477; rss: 439MB	borrow checking
time: 0.019; rss: 439MB	reachability checking
time: 0.038; rss: 439MB	death checking
time: 0.030; rss: 443MB	stability checking
time: 0.000; rss: 443MB	unused lib feature checking
time: 0.193; rss: 443MB	lint checking
time: 0.000; rss: 443MB	resolving dependency formats
  time: 0.003; rss: 443MB	NoLandingPads
  time: 0.026; rss: 443MB	SimplifyCfg
  time: 0.060; rss: 450MB	EraseRegions
  time: 0.011; rss: 450MB	AddCallGuards
  time: 0.266; rss: 466MB	ElaborateDrops
  time: 0.003; rss: 466MB	NoLandingPads
  time: 0.052; rss: 466MB	SimplifyCfg
  time: 0.028; rss: 466MB	InstCombine
  time: 0.013; rss: 466MB	Deaggregator
  time: 0.002; rss: 466MB	CopyPropagation
  time: 0.034; rss: 466MB	SimplifyLocals
  time: 0.010; rss: 466MB	AddCallGuards
  time: 0.003; rss: 466MB	PreTrans
time: 0.510; rss: 466MB	MIR optimisations
  time: 0.060; rss: 475MB	write metadata
  time: 0.386; rss: 491MB	translation item collection
  time: 0.066; rss: 497MB	codegen unit partitioning
  time: 0.047; rss: 739MB	internalize symbols
time: 4.411; rss: 739MB	translation
time: 0.000; rss: 739MB	assert dep graph
time: 0.000; rss: 739MB	serialize dep graph
  time: 0.520; rss: 419MB	llvm function passes [0]
  time: 0.243; rss: 429MB	llvm module passes [0]
  time: 10.320; rss: 420MB	codegen passes [0]
  time: 0.000; rss: 420MB	codegen passes [0]
time: 11.834; rss: 420MB	LLVM passes
time: 0.000; rss: 420MB	serialize work products
time: 0.340; rss: 105MB	linking
done
